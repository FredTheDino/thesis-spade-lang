\chapter{Conclusion}
\label{cha:Conclusion}
Programming languages are complex things -- but they need to be complex to express complex and precise ideas. The wordlenght inference outlined in this thesis shows a good way to extend the Spade hardware description language to more flexibly handle wordlengths. The wordlength inference works well with the current Damas–Hindley–Milner typechecker and will allow language designers of the Spade language to make an active choice in how the Spade language should interact with wordlengths. There was no difference in the resource usages of spade programs before or after the wordlength inference from this paper was introduced. The authors believe that the real benefit from these changes will not come from performance gains -- though better performance might be possible in the future -- but the ''soft'' value of expressiveness and clearer communication. A possibility of clearer intent will make it possible for the Spade-compiler to more clearly understand the programmer and might make other optimizations possible.


\section{How can interval arithmetic and affine arithmetic be used to implement wordlength inference?}
The most optimal way was to combine both interval arithmetic and affine arithmetic. Since both have differnt strengths and weaknesses the combination of the methods costs little in the way of resources but can in some instances give a lot smaller ranges which leads to smaller wordlengths. If this work is to be extended to support unsigned integers this combined method is bound to come in very handy. 

\section{How does wordlength inference and optimization affect the number of LUTs, DPS-blocks and memories for a circuit?}
This thesis clearly shows that this implementation of wordlenght inference has no discernible effect on any resource usage metrics.

\section{Can wordlength inference be used to create more reusable code?}
The final state of the changes from this thesis made the compiler very finicky about wordlengths. The expressiveness in the typesystem has increased which has made it possible to express some types more clearly and making certain function types more expressive, making it possible to do more things inside of functions -- aiding the reusability of code. Though it does not aid the resuability greatly the authors claim this is an improvement no matter how modest it is. That said, future work could easily expand on this.

\section{Future Work}
The implementation used in this thesis opens the door for an even more sophisticated approach where sub-expressions could be evaluated by either ''AA'' or ''IA''. One can consider an evaluation tree where all possible combinations of ''AA'' and ''IA'' are used -- though this tree might be too large to easily evaluate a technique like this would give theoretically optimal wordlengths for expressions. There is of course also the possibility of using a different method than ''AA'' and ''IA'' -- but adding more inference methods might make all the other approaches in the compiler even more potent.

Since the Spade-compiler now understands expressions and the values the expressions can be evaluated to it is trivial to check for expressions that evaluate to a constant. A constant expression is almost always a programmer error, but even when it isn't it should be replaced with the constant for clearer readability. This range analysis can also be used to trim dead code even before the codegeneration, and then warn about unreachable paths.

Since the compiler now reasons about ranges of integer values unsigned integer optimizations should be possible to do in a multitude of places. Maybe even automatically generating code that uses unsigned integers if the code never goes bellow 0. But this can ofcourse be taken a step further, and all expressions could be re-written by the compiler to avoid going bellow 0. We can trivially rewrite the expressions inside the compiler since integer arithmetic is a well behaved ring (unlike floating point numbers). This could lead to improved resource usage in some places. Maybe it could even be possible to shift the representation of numbers inside the compiler.

Some of the typing and inference rules need to be updated to make the language work well with e.g. Constants passed to functions. Looking into these kinds of rules could do a lot of the language, and pairing it with a usability study could be very beneficial.

There are also more advanced wordlenght inference methods. There are extensions to ''AA'' which might prove useful if implemented. Or maybe there are other completely novel methods that can be implemented. Maybe it is possible to track every possible integer value an expression can take, and allowing these holes in the expressions would make it possible to give even more precise guidance and help. Maybe it could be possible to pair the Spade-language with more complex formal verification methods.

Ofcourse all of these are ideas, but might be interesting to look into.
